/*******************************************************************************
 * Copyright (c) 2018-2019 Aion foundation.
 *
 *     This file is part of the aion network project.
 *
 *     The aion network project is free software: you can redistribute it
 *     and/or modify it under the terms of the GNU General Public License
 *     as published by the Free Software Foundation, either version 3 of
 *     the License, or any later version.
 *
 *     The aion network project is distributed in the hope that it will
 *     be useful, but WITHOUT ANY WARRANTY; without even the implied
 *     warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *     See the GNU General Public License for more details.
 *
 *     You should have received a copy of the GNU General Public License
 *     along with the aion network project source files.
 *     If not, see <https://www.gnu.org/licenses/>.
 *
 ******************************************************************************/

use std::fmt;
use types::ExecStatus;

pub trait EvmJit<T> {
    // generate raw pointer of type T for EvmJIT
    fn to_evm_jit(&mut self) -> *mut T;

    // transform data from raw pointer of type T to Rust data structure
    fn from_evm_jit(input: *const T) -> *const Self;
}

extern {
    // create fastvm instance, for internal use
    // it is a single instance, so always returns the same value
    pub fn fastvm_create() -> i64;
    // run fastvm
    // instance: created by fastvm_create
    // code: the execution code for Virtual Machine
    // len: code length, to avoid problem caused by ending char of different languages
    // context: the transaction context
    // revision: REVISION_AION = 5, for fastvm
    // result: the pre-allocated result buffer
    pub fn fastvm_run(
        instance: i64,
        code: *const u8,
        len: u32,
        context: *mut ::libc::wchar_t,
        revision: i32,
        result: *mut u8,
    ) -> EvmStatusCode;
    // environment pointer for talk between kernel and out-world VM
    // it is actually pointer of Externalities generated by as_externality in executive.rs
    // used for storage, code, balance and all other state related operations.
    pub fn env_init(cb_obj: *mut ::libc::c_void) -> i32;
}

#[derive(Debug, PartialEq, Clone, Copy)]
#[repr(C)]
/// The execution status code.
pub enum EvmStatusCode {
    // Execution finished with success.
    Success = 0,
    // Generic execution failure.
    Failure = 1,
    OutOfGas = 2,
    // for now, fastvm only returns Success, OutOfGas and Revert status
    BadInstruction = 3,
    BadJumpDescription = 4,
    StackOverflow = 5,
    StackUnderflow = 6,
    Revert = 7, //< Execution terminated with REVERT opcode.
    /// Tried to execute an operation which is restricted in static mode.
    StaticModeError = 8,
    /// The EVM rejected the execution of the given code or message.
    ///
    /// This error SHOULD be used to signal that the EVM is not able to or
    /// willing to execute the given code type or message.
    /// If an EVM returns the ::EVM_REJECTED status code,
    /// the Client MAY try to execute it in other EVM implementation.
    /// For example, the Client tries running a code in the EVM 1.5. If the
    /// code is not supported there, the execution falls back to the EVM 1.0.
    Rejected = -1,
    /// EVM implementation internal error.
    ///
    /// @todo We should rethink reporting internal errors. One of the options
    ///       it to allow using any negative value to represent internal errors.
    InternalError = -2,
}

impl fmt::Display for EvmStatusCode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match *self {
            EvmStatusCode::Success => write!(f, "Success"),
            EvmStatusCode::Failure => write!(f, "Failure"),
            EvmStatusCode::OutOfGas => write!(f, "Out of gas"),
            EvmStatusCode::BadInstruction => write!(f, "Bad instruction"),
            EvmStatusCode::BadJumpDescription => write!(f, "Bad jump description"),
            EvmStatusCode::StackOverflow => write!(f, "Stack overflow"),
            EvmStatusCode::StackUnderflow => write!(f, "Stack underflow"),
            EvmStatusCode::Revert => write!(f, "Revert"),
            EvmStatusCode::StaticModeError => write!(f, "Static mode error"),
            EvmStatusCode::Rejected => write!(f, "Rejected"),
            EvmStatusCode::InternalError => write!(f, "Internal error"),
        }
    }
}

#[derive(Debug, Clone)]
#[repr(C)]
// status_code: Success, Revert, OutOfGas
// gas_left: gas limit - transaction fee - vm execution cost
// output_data: returned by VM if any, NULL when no output data
// output_size: size of output_data if any
pub struct EvmResult {
    pub status_code: EvmStatusCode,
    pub gas_left: i64,
    pub output_data: *mut u8,
    pub output_size: usize,
}

// pre-alloc FVM's output data buffer
pub fn alloc_default_buf() -> *mut u8 {
    let res = unsafe {
        let out_ptr = ::libc::malloc(BUFFER_ALLOC_SIZE);
        ::std::mem::transmute(out_ptr)
    };
    res
}

// get header pointer of u8 array
pub fn get_libc_pointer_of_bytes(input: &[u8]) -> *mut ::libc::wchar_t {
    unsafe { ::std::mem::transmute(&input[0]) }
}

// pre-allocated buffer size for VM Execution Result's output data
// input data is limitted by GAS_CREATE_MAX: [5000000/64=78.125KB, 5000000/4=1.25MB]
// 1024 * 1024 * 10/8 = 1.256MB
const BUFFER_ALLOC_SIZE: usize = 1024 * 1024 * 10 / 8;

impl Into<EvmStatusCode> for ExecStatus {
    fn into(self) -> EvmStatusCode {
        match self {
            ExecStatus::Success => EvmStatusCode::Success,
            ExecStatus::OutOfGas => EvmStatusCode::OutOfGas,
            ExecStatus::Revert => EvmStatusCode::Revert,
            ExecStatus::Rejected => EvmStatusCode::Rejected,
            ExecStatus::Fatal => EvmStatusCode::InternalError,
            _ => EvmStatusCode::Failure,
        }
    }
}

impl From<EvmStatusCode> for ExecStatus {
    fn from(status: EvmStatusCode) -> ExecStatus {
        match status {
            EvmStatusCode::Success => ExecStatus::Success,
            EvmStatusCode::OutOfGas => ExecStatus::OutOfGas,
            EvmStatusCode::Revert => ExecStatus::Revert,
            EvmStatusCode::Rejected => ExecStatus::Rejected,
            EvmStatusCode::InternalError => ExecStatus::Fatal,
            _ => ExecStatus::Failure,
        }
    }
}
